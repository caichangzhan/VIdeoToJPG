<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
  <title>è§†é¢‘ 4:3 æˆªå›¾å·¥å…·ï¼ˆçº¯å‰ç«¯ï¼Œé€‚é…æ‰‹æœºï¼‰</title>
  <!-- å…³é”®ï¼šç¦æ­¢æ•´é¡µç¼©æ”¾ï¼Œé¿å…ä¸€ç¢°å°±æ”¾å¤§é¡µé¢ -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>

  <!-- Cropper.jsï¼š4:3 è£å‰ªæ¡† -->
  <link rel="stylesheet" href="https://unpkg.com/cropperjs@1.6.2/dist/cropper.min.css">
  <script src="https://unpkg.com/cropperjs@1.6.2/dist/cropper.min.js"></script>

  <!-- JSZipï¼šå‰ç«¯æ‰“åŒ… ZIP -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

  <style>
    :root {
      font-family:-apple-system,BlinkMacSystemFont,system-ui,sans-serif;
      background:#f3f4f6;
      color:#111827;
    }
    body {
      margin:0;
      padding:16px;
      display:flex;
      justify-content:center;
    }
    .container {
      width:100%;
      max-width:1100px;
      background:#fff;
      border-radius:16px;
      padding:16px;
      box-shadow:0 10px 25px rgba(15,23,42,.12);
    }
    h1 { margin:0 0 6px; font-size:20px; font-weight:600; }
    .sub { font-size:13px; color:#6b7280; margin-bottom:12px; }
    .section-title { margin:12px 0 6px; font-weight:600; font-size:14px; }
    input[type="file"] { font-size:14px; }

    #framePreview {
      max-width:420px;
      width:100%;
      max-height:420px;
      display:none;
      border-radius:12px;
      background:#000;
      touch-action:none; /* è®©æ‰‹åŠ¿ä¼˜å…ˆç»™ Cropperï¼Œç”¨äºæ‹–åŠ¨ï¼Œè€Œä¸æ˜¯æµè§ˆå™¨æ»šåŠ¨ */
    }

    #videoPlayer {
      max-width:420px;
      width:100%;
      display:none;
      border-radius:12px;
      margin-bottom:8px;
      background:#000;
    }

    button {
      padding:8px 14px;
      border:none;
      background:#2563eb;
      color:#fff;
      border-radius:999px;
      cursor:pointer;
      font-size:14px;
    }
    button:disabled { opacity:.5; cursor:not-allowed; }

    .row {
      display:flex;
      gap:12px;
      flex-wrap:wrap;
      align-items:flex-start;
    }

    #framesStrip {
      display:flex;
      gap:8px;
      overflow-x:auto;
      margin-top:10px;
    }
    .thumb {
      flex:0 0 auto;
      width:150px;
      background:#f9fafb;
      border-radius:12px;
      padding:4px;
      box-shadow:0 1px 4px rgba(0,0,0,.08);
      font-size:11px;
      text-align:center;
    }
    .thumb img {
      width:100%;
      border-radius:10px;
    }

    /* æ—¶é—´è½´ï¼šå¯æ‹–ä¸¤ç«¯ï¼Œå¯æ•´ä½“æ‹–åŠ¨ */
    #trimContainer {
      position: relative;
      width: 100%;
      max-width: 420px;
      height: 60px;
      margin-top: 6px;
      overflow: hidden;
      border-radius: 8px;
      background:#000;
    }
    #timeline {
      height: 100%;
      display: flex;
    }
    #timeline img {
      height: 100%;
      width: auto;
      flex-shrink: 0;
      object-fit: cover;
    }
    #trimOverlay {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
    }
    .handle {
      position: absolute;
      top: 0;
      width: 12px;
      height: 100%;
      background: rgba(255,255,255,0.9);
      border: 2px solid #fff;
      border-radius: 4px;
      cursor: ew-resize;
      box-shadow:0 0 4px rgba(0,0,0,.5);
      pointer-events:auto;
      z-index:2;
    }
    #leftHandle { left: 0; }
    #rightHandle { right: 0; }

    .shade {
      position: absolute;
      top: 0;
      height: 100%;
      background: rgba(0,0,0,0.5);
      pointer-events: none;
      z-index:1;
    }
    #shadeLeft  { left: 0; width: 0; }
    #shadeRight { right: 0; width: 0; }

    /* ä¸­é—´å¯æ‹–åŒºåŸŸï¼ˆæ•´ä½“ç§»åŠ¨é€‰åŒºï¼‰ */
    #windowDragArea {
      position:absolute;
      top:0;
      height:100%;
      cursor:grab;
      z-index:1;
      pointer-events:auto;
    }

    .button-row {
      display:flex;
      gap:8px;
      margin-top:8px;
      flex-wrap:wrap;
    }
    #downloadZipBtn {
      background:#059669;
    }
    #downloadZipBtn:disabled {
      background:#6b7280;
    }

    @media (max-width:600px){
      h1{font-size:18px;}
      .container{padding:12px;}
    }
  </style>
</head>
<body>

<div class="container">
  <h1>è§†é¢‘ 4:3 æˆªå›¾å·¥å…·</h1>
  <p class="sub">
    ä¸Šä¼ è§†é¢‘ â†’ æ’­æ”¾ä¸€ä¸‹è®©æµè§ˆå™¨â€œè®¤â€å®ƒ â†’ ç‚¹ã€Œç”Ÿæˆå‚è€ƒå¸§ã€â†’ 4:3 è£å‰ªï¼ˆæ‹–åŠ¨å›¾ç‰‡å³å¯ï¼Œä¸å†æ”¾å¤§ç¼©å°ï¼‰+ æ—¶é—´è½´é€‰åŒºï¼ˆâ‰¤8 ç§’ï¼Œå¯æ•´ä½“æ‹–åŠ¨ï¼‰â†’ çº¯å‰ç«¯åˆ‡å¸§ + ZIP ä¸‹è½½ã€‚
  </p>

  <!-- ç”¨åŒä¸€ä¸ª video åšé¢„è§ˆ / æ—¶é—´è½´ç¼©ç•¥å›¾ / æˆªå¸§ -->
  <video id="videoPlayer" controls playsinline webkit-playsinline muted></video>

  <!-- 1. ä¸Šä¼ è§†é¢‘ -->
  <div>
    <div class="section-title">1ï¸âƒ£ é€‰æ‹©è§†é¢‘</div>
    <input id="videoInput" type="file" accept="video/*">
    <div id="videoMeta" style="font-size:12px;color:#666;margin-top:4px;"></div>
  </div>

  <!-- 2. è£å‰ªå‚è€ƒå¸§ + æ—¶é—´åŒºé—´ -->
  <div style="margin-top:12px;">
    <div class="section-title">2ï¸âƒ£ æ’­æ”¾è§£é” â†’ ç”Ÿæˆå‚è€ƒå¸§ â†’ é€‰æ‹© 4:3 åŒºåŸŸ + æ—¶é—´åŒºé—´</div>
    <div class="row">
      <img id="framePreview" alt="å‚è€ƒå¸§"/>

      <div style="flex:1; min-width:260px; display:flex; flex-direction:column; gap:8px;">

        <button id="initBtn" disabled>ğŸ‘‰ ç”Ÿæˆå‚è€ƒå¸§ & æ—¶é—´è½´</button>
        <div style="font-size:12px;color:#6b7280;">é€‰å®Œè§†é¢‘åï¼Œå…ˆåœ¨ä¸Šé¢çš„æ’­æ”¾å™¨é‡Œéšä¾¿æ’­æ”¾ / æš‚åœä¸€ä¸‹ï¼Œå†ç‚¹è¿™ä¸ªæŒ‰é’®ã€‚</div>

        <label style="font-size:13px;">
          å¸§ç‡ FPSï¼š
          <input id="fpsInput" type="number" value="10" min="1" max="30" style="width:80px;">
        </label>

        <div class="section-title" style="margin:4px 0 4px;">æ—¶é—´åŒºé—´ï¼ˆç§’ï¼‰</div>
        <div id="trimContainer">
          <div id="timeline"></div>
          <div id="trimOverlay">
            <div id="shadeLeft" class="shade"></div>
            <div id="shadeRight" class="shade"></div>
            <div id="leftHandle" class="handle"></div>
            <div id="rightHandle" class="handle"></div>
            <div id="windowDragArea"></div>
          </div>
        </div>
        <div style="font-size:12px;color:#6b7280;margin-top:4px;">
          æ—¶é•¿æœ€å¤š 8 ç§’ï¼Œå¯è‡ªç”±è°ƒæ•´èµ·ç‚¹ / ç»ˆç‚¹ï¼Œé€‰åŒºå¯æ•´ä½“æ‹–åŠ¨ã€‚å½“å‰åŒºé—´ï¼š
          <span id="trimStart">0.0</span>s â€“ <span id="trimEnd">0.0</span>s
        </div>

        <div class="button-row">
          <button id="confirmBtn" disabled>å¼€å§‹åˆ‡å¸§ï¼ˆçº¯å‰ç«¯ï¼‰</button>
          <button id="downloadZipBtn" disabled>æ‰“åŒ…ä¸‹è½½å…¨éƒ¨å›¾ç‰‡</button>
        </div>

        <div id="statusText" style="font-size:12px;color:#666;">è¯·å…ˆé€‰æ‹©è§†é¢‘ã€‚</div>
      </div>
    </div>
  </div>

  <!-- 3. ç»“æœ -->
  <div style="margin-top:18px;">
    <div class="section-title">3ï¸âƒ£ åˆ‡å›¾ç»“æœï¼ˆæ¨ªå‘æ»šåŠ¨ï¼‰</div>
    <div id="framesStrip"></div>
  </div>
</div>

<script>
  const videoInput   = document.getElementById('videoInput');
  const videoPlayer  = document.getElementById('videoPlayer');
  const initBtn      = document.getElementById('initBtn');
  const framePreview = document.getElementById('framePreview');
  const fpsInput     = document.getElementById('fpsInput');
  const confirmBtn   = document.getElementById('confirmBtn');
  const downloadZipBtn = document.getElementById('downloadZipBtn');
  const statusText   = document.getElementById('statusText');
  const videoMeta    = document.getElementById('videoMeta');
  const framesStrip  = document.getElementById('framesStrip');

  // æ—¶é—´è½´ç›¸å…³
  const trimContainer = document.getElementById('trimContainer');
  const timeline      = document.getElementById('timeline');
  const leftHandle    = document.getElementById('leftHandle');
  const rightHandle   = document.getElementById('rightHandle');
  const shadeLeft     = document.getElementById('shadeLeft');
  const shadeRight    = document.getElementById('shadeRight');
  const windowDrag    = document.getElementById('windowDragArea');
  const trimStartEl   = document.getElementById('trimStart');
  const trimEndEl     = document.getElementById('trimEnd');

  let cropper = null;
  let selectedFile = null;

  let duration = 0;
  let trimStart = 0;
  let trimEnd = 0;
  let timelineWidth = 0;

  const MAX_WINDOW = 8;
  const MIN_WINDOW = 0.5;

  let currentFrames = [];
  let videoUrl = null;

  const isIOS = /iP(hone|od|ad)/.test(navigator.platform)
    || (navigator.userAgent.includes('Mac') && 'ontouchend' in document);

  async function unlockVideo() {
    if (!isIOS) return;
    try {
      await videoPlayer.play();
      videoPlayer.pause();
    } catch (e) {
      console.log('unlock error', e);
    }
  }

  // é€‰æ‹©è§†é¢‘
  videoInput.addEventListener('change', () => {
    const file = videoInput.files && videoInput.files[0];
    if (!file) return;

    selectedFile = file;
    confirmBtn.disabled = true;
    downloadZipBtn.disabled = true;
    initBtn.disabled = false;
    statusText.textContent = 'è¯·åœ¨ä¸‹æ–¹æ’­æ”¾å™¨ä¸­æ’­æ”¾ / æš‚åœä¸€ä¸‹ï¼Œç„¶åç‚¹å‡»ã€Œç”Ÿæˆå‚è€ƒå¸§ & æ—¶é—´è½´ã€ã€‚';
    framesStrip.innerHTML = '';
    videoMeta.textContent = '';
    currentFrames = [];

    if (videoUrl) URL.revokeObjectURL(videoUrl);
    videoUrl = URL.createObjectURL(file);

    videoPlayer.src = videoUrl;
    videoPlayer.style.display = 'block';

    videoPlayer.onloadedmetadata = () => {
      duration = videoPlayer.duration;
      videoMeta.textContent = `æ—¶é•¿ï¼š${duration.toFixed(1)} ç§’`;
    };
  });

  // ç”Ÿæˆå‚è€ƒå¸§ + æ—¶é—´è½´
  initBtn.addEventListener('click', async () => {
    if (!selectedFile) {
      alert('è¯·å…ˆé€‰æ‹©è§†é¢‘');
      return;
    }
    initBtn.disabled = true;
    statusText.textContent = 'æ­£åœ¨ç”Ÿæˆå‚è€ƒå¸§å’Œæ—¶é—´è½´â€¦';

    await unlockVideo();

    await setupPreviewFrameFromCurrent();
    await initTimelineFromVideo();

    confirmBtn.disabled = false;
    statusText.textContent = 'å‚è€ƒå¸§å’Œæ—¶é—´è½´å·²ç”Ÿæˆï¼Œå¯ä»¥è°ƒæ•´è£å‰ªåŒºåŸŸå’Œæ—¶é—´åŒºé—´ï¼Œç„¶åå¼€å§‹åˆ‡å¸§ã€‚';
  });

  async function setupPreviewFrameFromCurrent() {
    const captureTime = duration / 2;
    await seekVideo(captureTime);

    const canvas = document.createElement('canvas');
    canvas.width = videoPlayer.videoWidth;
    canvas.height = videoPlayer.videoHeight;
    const ctx = canvas.getContext('2d');
    ctx.drawImage(videoPlayer, 0, 0, canvas.width, canvas.height);

    framePreview.src = canvas.toDataURL('image/jpeg', 0.9);
    framePreview.style.display = 'block';

    if (cropper) {
      cropper.destroy();
      cropper = null;
    }

    // å…³é”®ï¼šç¦æ­¢ç¼©æ”¾ï¼Œåªå…è®¸æ‹–åŠ¨å›¾ç‰‡ç§»åŠ¨è£å‰ªåŒºåŸŸ
    cropper = new Cropper(framePreview, {
      aspectRatio: 4 / 3,
      viewMode: 1,
      autoCropArea: 1,
      dragMode: 'move',
      movable: true,
      zoomable: false,
      zoomOnTouch: false,
      zoomOnWheel: false,
      scalable: false,
      rotatable: false,
      background: false,
      guides: false,
      responsive: true,
      toggleDragModeOnDblclick: false
    });
  }

  function seekVideo(time) {
    return new Promise(resolve => {
      const handler = () => {
        videoPlayer.removeEventListener('seeked', handler);
        resolve();
      };
      videoPlayer.addEventListener('seeked', handler);
      videoPlayer.currentTime = time;
    });
  }

  async function initTimelineFromVideo() {
    const thumbs = [];
    const framesCount = Math.min(16, Math.max(6, Math.round(duration * 1.5)));

    for (let i = 0; i < framesCount; i++) {
      const t = duration * (i + 0.5) / framesCount;
      await seekVideo(t);

      const cnv = document.createElement('canvas');
      cnv.width = 60;
      cnv.height = 60;
      const ctx = cnv.getContext('2d');
      ctx.drawImage(videoPlayer, 0, 0, cnv.width, cnv.height);
      thumbs.push(cnv.toDataURL());
    }

    timeline.innerHTML = '';
    thumbs.forEach(src => {
      const img = document.createElement('img');
      img.src = src;
      timeline.appendChild(img);
    });

    await new Promise(r => requestAnimationFrame(r));
    const rect = timeline.getBoundingClientRect();
    timelineWidth = rect.width || trimContainer.clientWidth;

    const initLen = Math.min(MAX_WINDOW, duration);
    trimStart = 0;
    trimEnd   = initLen;

    syncUIFromTimes();
    setupHandleDrag();
    setupWindowDrag();
  }

  function timeToX(t) {
    if (!duration || !timelineWidth) return 0;
    return (t / duration) * timelineWidth;
  }
  function xToTime(x) {
    if (!timelineWidth || !duration) return 0;
    return (x / timelineWidth) * duration;
  }

  function syncUIFromTimes() {
    const leftX  = timeToX(trimStart);
    const rightX = timeToX(trimEnd);

    leftHandle.style.left   = `${leftX}px`;
    rightHandle.style.right = `${timelineWidth - rightX}px`;

    shadeLeft.style.width   = `${leftX}px`;
    shadeRight.style.width  = `${timelineWidth - rightX}px`;

    windowDrag.style.left   = `${leftX}px`;
    windowDrag.style.width  = `${Math.max(0, rightX - leftX)}px`;

    trimStartEl.textContent = trimStart.toFixed(1);
    trimEndEl.textContent   = trimEnd.toFixed(1);
  }

  function clampWindow(start, end) {
    let s = Math.max(0, Math.min(start, duration));
    let e = Math.max(0, Math.min(end, duration));
    if (e < s) [s, e] = [e, s];

    let len = e - s;
    if (len < MIN_WINDOW) {
      e = Math.min(duration, s + MIN_WINDOW);
      s = e - MIN_WINDOW;
      len = MIN_WINDOW;
    }
    if (len > MAX_WINDOW) {
      e = s + MAX_WINDOW;
      if (e > duration) {
        e = duration;
        s = e - MAX_WINDOW;
      }
      len = MAX_WINDOW;
    }
    return { start: s, end: e };
  }

  function setupHandleDrag() {
    leftHandle.onpointerdown = (e) => {
      e.preventDefault();
      const startX = e.clientX;
      const origLeftX = timeToX(trimStart);

      const move = (ev) => {
        const dx = ev.clientX - startX;
        let newLeftX = origLeftX + dx;
        newLeftX = Math.max(0, Math.min(newLeftX, timeToX(trimEnd) - 1));

        let newStart = xToTime(newLeftX);
        let { start, end } = clampWindow(newStart, trimEnd);
        trimStart = start;
        trimEnd   = end;

        syncUIFromTimes();
      };

      const up = () => {
        document.removeEventListener('pointermove', move);
        document.removeEventListener('pointerup', up);
      };

      document.addEventListener('pointermove', move);
      document.addEventListener('pointerup', up);
    };

    rightHandle.onpointerdown = (e) => {
      e.preventDefault();
      const startX = e.clientX;
      const origRightX = timeToX(trimEnd);

      const move = (ev) => {
        const dx = ev.clientX - startX;
        let newRightX = origRightX + dx;
        newRightX = Math.min(timelineWidth, Math.max(newRightX, timeToX(trimStart) + 1));

        let newEnd = xToTime(newRightX);
        let { start, end } = clampWindow(trimStart, newEnd);
        trimStart = start;
        trimEnd   = end;

        syncUIFromTimes();
      };

      const up = () => {
        document.removeEventListener('pointermove', move);
        document.removeEventListener('pointerup', up);
      };

      document.addEventListener('pointermove', move);
      document.addEventListener('pointerup', up);
    };
  }

  function setupWindowDrag() {
    windowDrag.onpointerdown = (e) => {
      e.preventDefault();
      windowDrag.style.cursor = 'grabbing';

      const startX = e.clientX;
      const origStart = trimStart;
      const origEnd   = trimEnd;

      const move = (ev) => {
        const dx = ev.clientX - startX;
        const deltaTime = xToTime(dx) - xToTime(0);

        let newStart = origStart + deltaTime;
        let newEnd   = origEnd + deltaTime;

        if (newStart < 0) {
          newEnd -= newStart;
          newStart = 0;
        }
        if (newEnd > duration) {
          const over = newEnd - duration;
          newStart -= over;
          newEnd = duration;
          if (newStart < 0) newStart = 0;
        }

        const res = clampWindow(newStart, newEnd);
        trimStart = res.start;
        trimEnd   = res.end;

        syncUIFromTimes();
      };

      const up = () => {
        windowDrag.style.cursor = 'grab';
        document.removeEventListener('pointermove', move);
        document.removeEventListener('pointerup', up);
      };

      document.addEventListener('pointermove', move);
      document.addEventListener('pointerup', up);
    };
  }

  async function processVideoFrames() {
    const fps = Number(fpsInput.value) || 10;
    if (!selectedFile || !cropper || !fps) return;

    const cropData = cropper.getData(true);
    const startSec = trimStart;
    const endSec   = trimEnd;
    const span     = endSec - startSec;
    if (span <= 0) {
      alert('æ—¶é—´åŒºé—´ä¸åˆæ³•');
      return;
    }

    const step = 1 / fps;
    const frameTimes = [];
    for (let t = startSec; t <= endSec + 1e-4; t += step) {
      frameTimes.push(Math.min(t, endSec));
    }

    statusText.textContent = `å…± ${frameTimes.length} å¸§ï¼Œæ­£åœ¨æˆªå–â€¦`;
    framesStrip.innerHTML = '';
    currentFrames = [];
    downloadZipBtn.disabled = true;

    await unlockVideo();

    const canvas = document.createElement('canvas');
    canvas.width  = Math.round(cropData.width);
    canvas.height = Math.round(cropData.height);
    const ctx = canvas.getContext('2d');

    for (let i = 0; i < frameTimes.length; i++) {
      const t = frameTimes[i];
      statusText.textContent = `æ­£åœ¨æˆªå–å¸§ ${i+1}/${frameTimes.length}ï¼ˆ${t.toFixed(2)}sï¼‰â€¦`;

      await seekVideo(t);

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(
        videoPlayer,
        cropData.x, cropData.y, cropData.width, cropData.height,
        0, 0, canvas.width, canvas.height
      );

      const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/jpeg', 0.9));
      if (!blob) continue;
      currentFrames.push(blob);

      const imgUrl = URL.createObjectURL(blob);
      const div = document.createElement('div');
      div.className = 'thumb';
      const img = document.createElement('img');
      img.src = imgUrl;
      div.appendChild(img);
      const label = document.createElement('div');
      label.textContent = `#${i+1}`;
      div.appendChild(label);
      framesStrip.appendChild(div);
    }

    statusText.textContent = `æˆªå–å®Œæˆï¼šå…± ${currentFrames.length} å¸§ã€‚`;
    if (currentFrames.length > 0) {
      downloadZipBtn.disabled = false;
    }
  }

  confirmBtn.addEventListener('click', async () => {
    if (!selectedFile || !cropper) {
      alert('è¯·å…ˆé€‰æ‹©è§†é¢‘å¹¶å®Œæˆè£å‰ª');
      return;
    }
    confirmBtn.disabled = true;
    downloadZipBtn.disabled = true;

    try {
      await processVideoFrames();
    } catch (e) {
      console.error(e);
      alert('åˆ‡å¸§å¤±è´¥ï¼š' + e.message);
      statusText.textContent = 'åˆ‡å¸§å¤±è´¥ï¼š' + e.message;
    } finally {
      confirmBtn.disabled = false;
    }
  });

  downloadZipBtn.addEventListener('click', async () => {
    if (!currentFrames.length) return;

    downloadZipBtn.disabled = true;
    statusText.textContent = 'æ­£åœ¨æ‰“åŒ… ZIPâ€¦';

    try {
      const zip = new JSZip();
      const folder = zip.folder('frames');

      for (let i = 0; i < currentFrames.length; i++) {
        const blob = currentFrames[i];
        const indexStr = String(i + 1).padStart(3, '0');
        folder.file(`frame-${indexStr}.jpg`, blob);
      }

      const zipBlob = await zip.generateAsync({ type: 'blob' });
      const a = document.createElement('a');
      const url = URL.createObjectURL(zipBlob);
      a.href = url;
      a.download = 'frames.zip';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);

      statusText.textContent = 'ZIP æ‰“åŒ…å®Œæˆï¼Œå·²å¼€å§‹ä¸‹è½½ã€‚';
    } catch (e) {
      console.error(e);
      alert('æ‰“åŒ…å¤±è´¥ï¼š' + e.message);
      statusText.textContent = 'æ‰“åŒ…å¤±è´¥ï¼š' + e.message;
    } finally {
      if (currentFrames.length) {
        downloadZipBtn.disabled = false;
      }
    }
  });
</script>

</body>
</html>
